//
// Created by Nexus Pancakes on 6/11/2022.
//

#include <iostream>
#include <thread>
#include <mach-o/dyld.h>
#include <unistd.h>
#include <map>
#include <filesystem>

#include "scripts.h"
#include "exploit.h"
#include "functions.h"
#include "communication.h"
#include "whitelist.h"
#include "drawing.h"
#include "roblox_rpc.h"

#define NS_PRIVATE_IMPLEMENTATION
#define CA_PRIVATE_IMPLEMENTATION
#define MTL_PRIVATE_IMPLEMENTATION

#include <Foundation/Foundation.hpp>
#include <Metal/Metal.hpp>
#include <QuartzCore/QuartzCore.hpp>

bool experiment_index = false;

bool valid_thread(uint64_t rl) {
    if (!rl) return false;
    (*rbx_getfield)(rl, LUA_GLOBALSINDEX, "game");
    (*rbx_getfield)(rl, -1, "PlaceId");

    (*rbx_insert)(rl, -2);
    rbx_pop(rl, 1);

    auto val = (roblox_structs::TValue*)rbx_index2addr(rl, -1);
    int nval = static_cast<int>(val->value.n);
    rbx_pop(rl, 1);

    return nval != 0;
}

void console_listener() {
    while (true) {
        std::string script = "";
        std::getline(std::cin, script);
        
        if (script != "" && whitelisted && roblox_thread) {
            execute_script(roblox_thread, script);
        }
    }
}

void exploit_thread() {
    std::thread(multi_service).detach();
    std::cout << "[Abyss] Started Multi Roblox.\n";

    std::thread(whitelist_check, settings::get_boolean("discordRpc")).detach();
    std::cout << "[Abyss] Started Whitelist Thread.\n";
    
    std::unordered_map<std::string, bool> backup_settings;
    backup_settings = settings::bool_settings;

    while (true) {
        std::cout << std::hex;
        std::cout << "[Abyss] Beginning Execution Thread...\n";
        std::cout << "[Abyss] " << std::dec << hook::scripts_executed << std::hex << " Scripts Have Been Executed.\n";

        roblox_thread = 0;
        deserialize_thread = 0;
        uint64_t script_context = 0;
        scheduler::job* scripts_job = nullptr;
        while (*(uint64_t*)taskscheduler_address == 0) {
            sleep(1);
        }

        uint64_t scripts_index = 0;
        if (!settings::refreshed || !settings::get_boolean("macsploit")) {
            settings::bool_settings = backup_settings;
            settings::refreshed = true;
            settings::reload();
        }

        uint64_t scheduler = *(uint64_t*)taskscheduler_address;
        std::cout << "[Abyss] Searching for game @ 0x" << scheduler << "...\n";

        if (settings::get_boolean("autoInject")) {
            *(double*)(scheduler + 0x138) = 1 / 400.0;
        }

        while (scripts_job == nullptr) {
            scheduler::scheduler_jobs.clear();
            sleep(1);

            uint64_t start = *(uint64_t*)(scheduler + offsets::jobs_start);
            uint64_t end = *(uint64_t*)(scheduler + offsets::jobs_end);

            while (start < end) {
                auto job = *(scheduler::job**)start;
                scheduler::scheduler_jobs.push_back(job);

                if (job->job_name == "WaitingHybridScriptsJob" && roblox_thread == 0) {
                    const int64_t trigger = 0;
                    void** job_address = (void**)job;
                    script_context = (uint64_t)job_address[offsets::hybridscriptsjob::script_context];
                    uint64_t rbx_state = (*rbx_getstate)(script_context, &thread_type, &trigger);

                    if (valid_thread(rbx_state)) {
                        scripts_job = job;
                        scripts_index = start;
                        roblox_thread = rbx_state;
                    }
                }

                start += offsets::jobs_offset;
            }
        }

        if (roblox_thread == 0) {
            std::cout << "[Abyss] Failed to Initialize Roblox Thread.\n";
            break;
        }

        for (auto job : scheduler::scheduler_jobs) {
            std::cout << "[Abyss] Job Found: " << job->job_name << "\n";
        }

        std::cout << "[Abyss] WaitingHybridScriptsJob Hooked.\n";
        std::cout << "[Abyss] WaitingHybridScriptsJob: 0x" << (uint64_t)scripts_job << "\n";
        std::cout << "[Abyss] Lua State: 0x" << roblox_thread << "\n";
        if (!settings::get_boolean("macsploit")) {
            settings::reload_config();
        }

        scripts_thread = roblox_thread;
        roblox_thread = (*rbx_newthread)(scripts_thread);
        deserialize_thread = (*rbx_newthread)(scripts_thread);
        
        scripts_env = filter_globals(roblox_thread);
        *(uint64_t*)(deserialize_thread + offsets::state_env) = exploit_env;

        std::cout << "[Abyss] Filtered Thread Globals.\n";
        rbx_setidentity(roblox_thread, global_identity);

        std::cout << "[Abyss] Set Thread Identity to 8.\n";
        std::cout << "[Abyss] Abyss Thread Created!\n";
        
        init_functions(roblox_thread);
        std::cout << "[Abyss] Functions Ready.\n";

        hidden_seed = skidded_gen_random(8);
        if (script_author != default_author) {
            script_author = std::string("=script ." + hidden_seed).c_str();
        }

        std::cout << "[Abyss] Created Secure Seed.\n";
        execute_script(roblox_thread, init_script);

        execute_script(roblox_thread, seaweed_decompiler);
        std::cout << "[Abyss] Injected Shellcode.\n";

        if (settings::get_boolean("robloxRpc")) {
            execute_script(roblox_thread, rpc_loader);
            std::cout << "[Abyss] Connected RPC Server.\n";
        }

        execute_script(roblox_thread, drawing_test);
        std::cout << "[Abyss] Skidded Drawing Library.\n";

        if (settings::get_boolean("norbUnc")) {
            execute_script(roblox_thread, norb_unc);
            std::cout << "[Abyss] NorbDev UNC Loaded.\n";
        }

        if (settings::get_boolean("autoExecute")) {
            int e_count = setup_autoexec(roblox_thread);
            if (e_count) {
                std::cout << std::dec;
                std::cout << "[Abyss] Scheduled " << e_count << " Script(s) for Execution.\n";
                std::cout << std::hex;;
            }
        }

        if (settings::get_boolean("settingsControl") && teleport_event && teleport_script_queue.size() > 0) {
            std::cout << "[Abyss] Teleportation Detected, Scripts Will Be Executed.\n";
            for (auto script : teleport_script_queue) {
                execute_script(roblox_thread, script);
            }

            teleport_script_queue.clear();
        }

        teleport_event = false;
        std::cout << "[Abyss] Re-Injection Service Ready.\n";
        std::cout << "[Abyss] Thread Complete.\n";

        while (roblox_thread) {
            if (experiment_index) {
                uint64_t start = *(uint64_t*)(scheduler + offsets::jobs_start);
                auto job = *(scheduler::job**)scripts_index;
                if (job->job_name != "WaitingHybridScriptsJob") {
                    break;
                }
            }

            usleep(1000000);
            uint64_t current_context = 0;
            uint64_t start = *(uint64_t*)(scheduler + offsets::jobs_start);
            uint64_t end = *(uint64_t*)(scheduler + offsets::jobs_end);

            while (start < end) {
                auto job = *(scheduler::job**)start;
                if (job == scripts_job) {
                    void** job_address = (void**)job;
                    current_context = (uint64_t)job_address[offsets::hybridscriptsjob::script_context];
                }

                start += offsets::jobs_offset;
            }

            if (current_context != script_context) {
                break;
            }
        }

        std::cout << "[Abyss] Re-Injection Detected, Reloading...\n";
    }
}

void map_functions() {
    aslr_slide = _dyld_get_image_vmaddr_slide(0);
    deserialize_exit = deserialize_address + 0x6;
    teleport_exit = teleport_address + 0x6;

    print_address = apply_aslr(print_address);
    taskscheduler_address = apply_aslr(taskscheduler_address);
    deserialize_address = apply_aslr(deserialize_address);
    spawn_address = apply_aslr(spawn_address);
    settop_address = apply_aslr(settop_address);
    setfield_address = apply_aslr(setfield_address);
    pushcclosure_address = apply_aslr(pushcclosure_address);
    tolstring_address = apply_aslr(tolstring_address);
    pushlstring_address = apply_aslr(pushlstring_address);
    error_address = apply_aslr(error_address);
    pushvalue_address = apply_aslr(pushvalue_address);
    newthread_address = apply_aslr(newthread_address);
    getfield_address = apply_aslr(getfield_address);
    getmetatable_address = apply_aslr(getmetatable_address);
    checkany_address = apply_aslr(checkany_address);
    pseudo2addr_address = apply_aslr(pseudo2addr_address);
    pcall_address = apply_aslr(pcall_address);
    insert_address = apply_aslr(insert_address);
    rawseti_address = apply_aslr(rawseti_address);
    createtable_address = apply_aslr(createtable_address);
    getstate_address = apply_aslr(getstate_address);
    next_address = apply_aslr(next_address);
    pushnumber_address = apply_aslr(pushnumber_address);
    newlclosure_address = apply_aslr(newlclosure_address);
    getinfo_address = apply_aslr(getinfo_address);
    visitgco_address = apply_aslr(visitgco_address);
    resume_address = apply_aslr(resume_address);
    rawgeti_address = apply_aslr(rawgeti_address);
    setmetatable_address = apply_aslr(setmetatable_address);
    getnum_address = apply_aslr(getnum_address);
    newudata_address = apply_aslr(newudata_address);
    fireclickdetector_addr = apply_aslr(fireclickdetector_addr);
    ltolstring_address = apply_aslr(ltolstring_address);
    appendtouch_addr = apply_aslr(appendtouch_addr);

    gettable_address = apply_aslr(gettable_address);
}

void dylib_entry() {
    map_functions();
    if (*(char*)print_address != 0x55) {
        std::cout << "[Abyss] Failed to Start.\n";
        return;
    }

    std::cout << std::hex << std::uppercase;
    std::cout << anon;
   
    settings::reload_config();

    if (macsploit_safemode) {
        std::cout << "[Abyss] Safe Mode Enabled.\n";
        hook::hook_detection_1();
        std::cout << "[Abyss] Implemented Anti-Detection.\n[Abyss] Starting Roblox Without Macsploit...\n\n";
        std::cout << std::uppercase;
        return;
    }

    hook::safe_hook_context(hook::old_context_hook);
    hook::hook_deserialize(hook::deserialize_hook);
    hook::hook_detection_1();
    hook::hook_teleports();
    hook::hook_private();
    hook::hook_connect();

    std::cout << "[Abyss] Current Directory: " << std::filesystem::current_path().string() << "\n";;
    std::cout << "[Abyss] Memory Patched.\n[Abyss] Abyss Injected Successfully.\n";
    std::thread(exploit_thread).detach();

    if (std::filesystem::exists(session_file)) {
        std::string chunk;

        std::ifstream file(session_file);
        getline(file, chunk);
        file.close();

        if (chunk != "") {
            strcpy(hook::roblox_session, chunk.c_str());
            hook::rbx_fmtcurl = (hook::fmtcurl_t)hook::hook_address_2(fmtcurl_address, (void*)hook::fmtcurl_hook);
            std::cout << "[Abyss] Loaded Custom Session Cookie.\n";
        }
    }

    std::thread(console_listener).detach();
    std::cout << "[Abyss] Attached Console Input to Execution.\n";

    std::thread(init_socket).detach();
    std::cout << "[Abyss] Created Socket for IPC Communication.\n[Abyss] Starting Roblox...\n\n";
    
    std::cout << std::uppercase;
}